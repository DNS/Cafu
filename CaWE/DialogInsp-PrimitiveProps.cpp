/*
=================================================================================
This file is part of Cafu, the open-source game engine and graphics engine
for multiplayer, cross-platform, real-time 3D action.
Copyright (C) 2002-2011 Carsten Fuchs Software.

Cafu is free software: you can redistribute it and/or modify it under the terms
of the GNU General Public License as published by the Free Software Foundation,
either version 3 of the License, or (at your option) any later version.

Cafu is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Cafu. If not, see <http://www.gnu.org/licenses/>.

For support and more information about Cafu, visit us at <http://www.cafu.de>.
=================================================================================
*/

#include "DialogInsp-PrimitiveProps.hpp"
#include "MapBrush.hpp"
#include "MapBezierPatch.hpp"
#include "MapDocument.hpp"
#include "MapEntityBase.hpp"
#include "MapModel.hpp"
#include "MapPlant.hpp"
#include "MapTerrain.hpp"
#include "GameConfig.hpp"

#include "MapCommands/ChangePlantSeed.hpp"
#include "MapCommands/ChangePlantDescr.hpp"
#include "MapCommands/ModifyModel.hpp"

#include "wx/notebook.h"
#include "wx/propgrid/propgrid.h"
#include "wx/propgrid/manager.h"
#include "wx/propgrid/advprops.h"

#include "Models/Model_cmdl.hpp"
#include "TypeSys.hpp"


class GameFilePropertyT : public wxLongStringProperty
{
    public:

    GameFilePropertyT(const wxString& name=wxPG_LABEL,
                      const wxString& label=wxPG_LABEL,
                      const wxString& value=wxEmptyString,
                      MapDocumentT* MapDoc_=NULL,
                      wxString Filter_="All files (*.*)|*.*",
                      wxString SubDir_=wxEmptyString)
        : wxLongStringProperty(name, label, value),
          MapDoc(MapDoc_),
          Filter(Filter_),
          SubDir(SubDir_)
    {
    }

    // Shows the file selection dialog and makes the choosen file path relative.
    virtual bool OnButtonClick(wxPropertyGrid* propGrid, wxString& value)
    {
        wxString InitialDir =MapDoc->GetGameConfig()->ModDir+SubDir;
        wxString FileNameStr=wxFileSelector("Please select a file", InitialDir, "", "", Filter, wxFD_OPEN | wxFD_FILE_MUST_EXIST);

        if (FileNameStr=="") return false;

        wxFileName FileName(FileNameStr);
        FileName.MakeRelativeTo(MapDoc->GetGameConfig()->ModDir);
        value=FileName.GetFullPath(wxPATH_UNIX);
        return true;
    }


    private:

    MapDocumentT* MapDoc;
    wxString      Filter;
    wxString      SubDir;
};


BEGIN_EVENT_TABLE(InspDlgPrimitivePropsT, wxPanel)
    EVT_PG_CHANGED(ID_PROPERTY_GRID_MAN, InspDlgPrimitivePropsT::OnPropertyGridChanged)
END_EVENT_TABLE()


wxSizer* InspDlgPrimitivePropsT::InspectorPrimitivePropsInit(wxWindow* parent, bool call_fit, bool set_sizer)
{
    wxBoxSizer *item0 = new wxBoxSizer( wxVERTICAL );

    SelectionText=new wxStaticText(parent, -1, wxT("No map primitve is selected."), wxDefaultPosition, wxDefaultSize, 0);
    item0->Add(SelectionText, 0, wxALIGN_CENTER_VERTICAL|wxALL, 2);

    // BEGIN CUSTOM code, not generated by wxDesigner.

    PropMan=new wxPropertyGridManager(this, ID_PROPERTY_GRID_MAN, wxDefaultPosition, wxDefaultSize, wxPG_BOLD_MODIFIED | wxPG_SPLITTER_AUTO_CENTER | wxPG_TOOLBAR | wxPG_DESCRIPTION);
    PropMan->SetExtraStyle(wxPG_EX_HELP_AS_TOOLTIPS | wxPG_EX_MODE_BUTTONS);

    PropMan->AddPage("Properties");

    // END CUSTOM code, not generated by wxDesigner.

    item0->Add( PropMan, 1, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 2 );

    if (set_sizer)
    {
        parent->SetSizer( item0 );
        if (call_fit)
            item0->SetSizeHints( parent );
    }

    return item0;
}


InspDlgPrimitivePropsT::InspDlgPrimitivePropsT(wxWindow* Parent_, MapDocumentT* MapDoc_)
    : wxPanel(Parent_),
      MapDoc(MapDoc_),
      SelectionText(NULL),
      IsRecursiveSelfNotify(false)
{
    InspectorPrimitivePropsInit(this);
    MapDoc->RegisterObserver(this);
}


InspDlgPrimitivePropsT::~InspDlgPrimitivePropsT()
{
    PropMan->Clear();
    if (MapDoc) MapDoc->UnregisterObserver(this);
}


void InspDlgPrimitivePropsT::NotifySubjectChanged_Selection(SubjectT* Subject, const ArrayT<MapElementT*>& OldSelection, const ArrayT<MapElementT*>& NewSelection)
{
    if (IsRecursiveSelfNotify) return;

    UpdateGrid();
}


void InspDlgPrimitivePropsT::NotifySubjectChanged_Deleted(SubjectT* Subject, const ArrayT<MapElementT*>& MapElements)
{
    // No need to react on deleted objects.
    // If the deletion of an object changes the current selection the inspector is notified in the NotifySubjectChanged_Selection method.
}


void InspDlgPrimitivePropsT::NotifySubjectChanged_Modified(SubjectT* Subject, const ArrayT<MapElementT*>& MapElements, MapElemModDetailE Detail)
{
    if (IsRecursiveSelfNotify) return;

    if (Detail!=MEMD_PRIMITIVE_PROPS_CHANGED && Detail!=MEMD_GENERIC) return;

    for (unsigned long i=0; i<MapElements.Size(); i++)
    {
        if (MapElements[i]->IsSelected())
        {
            UpdateGrid();
            break;
        }
    }
}


void InspDlgPrimitivePropsT::NotifySubjectChanged_Modified(SubjectT* Subject, const ArrayT<MapElementT*>& MapElements, MapElemModDetailE Detail, const ArrayT<BoundingBox3fT>& OldBounds)
{
    if (IsRecursiveSelfNotify) return;

    if (Detail!=MEMD_PRIMITIVE_PROPS_CHANGED) return;

    for (unsigned long i=0; i<MapElements.Size(); i++)
    {
        if (MapElements[i]->IsSelected())
        {
            UpdateGrid();
            break;
        }
    }
}


void InspDlgPrimitivePropsT::NotifySubjectDies(SubjectT* dyingSubject)
{
    wxASSERT(dyingSubject==MapDoc);
    MapDoc=NULL;
}


void InspDlgPrimitivePropsT::UpdateGrid()
{
    ArrayT<MapPrimitiveT*> SelectedPrimitives;

    // Loop over the map selection in order to determine the list of selected map primitves.
    for (unsigned long i=0; i<MapDoc->GetSelection().Size(); i++)
    {
        MapPrimitiveT* Prim=dynamic_cast<MapPrimitiveT*>(MapDoc->GetSelection()[i]);

        if (Prim)
        {
            SelectedPrimitives.PushBack(Prim);
            continue;
        }

        MapEntityBaseT* Ent=dynamic_cast<MapEntityBaseT*>(MapDoc->GetSelection()[i]);

        if (Ent)
        {
            SelectedPrimitives.PushBack(Ent->GetPrimitives());
            continue;
        }
    }

    // Update the selection description text.
    if (SelectedPrimitives.Size()==0)
        SelectionText->SetLabel("No map primitive selected.");
    else if (SelectedPrimitives.Size()==1)
        SelectionText->SetLabel("1 map primitive selected.");
    else
        SelectionText->SetLabel(wxString::Format("%lu map primitives selected.", SelectedPrimitives.Size()));

    PropMan->ClearSelection();              // Clear the property grid.
    PropMan->ClearPage(0);                  // At the moment we only got one page, so we only need to delete this page.

    unsigned int BrushCount  =0;
    unsigned int BPCount     =0;
    unsigned int TerrainCount=0;
    unsigned int PlantCount  =0;
    unsigned int ModelCount  =0;

    // Create a category for every selected map primitve and fill it with the primitves properties.
    for (unsigned long i=0; i<SelectedPrimitives.Size(); i++)
    {
        if (dynamic_cast<MapBrushT*>(SelectedPrimitives[i])!=NULL)
        {
            wxPGProperty* Cat=PropMan->Append(new wxStringProperty(SelectedPrimitives[i]->GetType()->ClassName+wxString::Format("%i", ++BrushCount), wxPG_LABEL, "<composed>"));
            PropMan->DisableProperty(Cat);
        }

        if (dynamic_cast<MapBezierPatchT*>(SelectedPrimitives[i])!=NULL)
        {
            wxPGProperty* Cat=PropMan->Append(new wxStringProperty(SelectedPrimitives[i]->GetType()->ClassName+wxString::Format("%i", ++BPCount), wxPG_LABEL, "<composed>"));
            PropMan->DisableProperty(Cat);
        }

        if (dynamic_cast<MapTerrainT*>(SelectedPrimitives[i])!=NULL)
        {
            wxPGProperty* Cat=PropMan->Append(new wxStringProperty(SelectedPrimitives[i]->GetType()->ClassName+wxString::Format("%i", ++TerrainCount), wxPG_LABEL, "<composed>"));
            PropMan->DisableProperty(Cat);
        }

        if (dynamic_cast<MapPlantT*>(SelectedPrimitives[i])!=NULL)
        {
            wxPGProperty* Cat=PropMan->Append(new wxStringProperty(SelectedPrimitives[i]->GetType()->ClassName+wxString::Format("%i", ++PlantCount), wxPG_LABEL, "<composed>"));
            PropMan->DisableProperty(Cat);

            MapPlantT* Plant=(MapPlantT*)SelectedPrimitives[i];

            PropMan->AppendIn(Cat, new GameFilePropertyT("Plant Description", wxPG_LABEL, Plant->m_DescrFileName, MapDoc, "Plant Description Files (*.cpd)|*.cpd|All Files (*.*)|*.*", "/Plants/"))->SetClientData(Plant);
            PropMan->AppendIn(Cat, new wxIntProperty("Random Seed", wxPG_LABEL, Plant->m_RandomSeed))->SetClientData(Plant);
        }

        if (dynamic_cast<MapModelT*>(SelectedPrimitives[i])!=NULL)
        {
            wxPGProperty* Cat=PropMan->Append(new wxStringProperty(SelectedPrimitives[i]->GetType()->ClassName+wxString::Format("%i", ++ModelCount), wxPG_LABEL, "<composed>"));
            PropMan->DisableProperty(Cat);

            MapModelT* Model=(MapModelT*)SelectedPrimitives[i];

            PropMan->AppendIn(Cat, new GameFilePropertyT("Model",           wxPG_LABEL, Model->m_Model->GetFileName(), MapDoc, "All Files (*.*)|*.*|Model files (*.mdl)|*.mdl|Model Files (*.ase)|*.ase|Model Files (*.dlod)|*.dlod", "/Models/"))->SetClientData(Model);
            PropMan->AppendIn(Cat, new GameFilePropertyT("Collision Model", wxPG_LABEL, Model->m_CollModelFileName, MapDoc, "Collision Model (*.cmap)|*.cmap|All Files (*.*)|*.*", "/Models/"))->SetClientData(Model);
            PropMan->AppendIn(Cat, new wxStringProperty ("Label",           wxPG_LABEL, Model->m_Label))->SetClientData(Model);
            PropMan->AppendIn(Cat, new wxFloatProperty  ("Scale",           wxPG_LABEL, Model->m_Scale))->SetClientData(Model);
            PropMan->AppendIn(Cat, new wxIntProperty    ("Sequence Number", wxPG_LABEL, Model->m_SeqNumber))->SetClientData(Model);
            PropMan->AppendIn(Cat, new wxFloatProperty  ("Frame Offset",    wxPG_LABEL, Model->m_FrameOffset))->SetClientData(Model);
            PropMan->AppendIn(Cat, new wxFloatProperty  ("Frame Scale",     wxPG_LABEL, Model->m_FrameTimeScale))->SetClientData(Model);

            wxPGProperty* AnimateProp=PropMan->AppendIn(Cat, new wxBoolProperty("Animated", wxPG_LABEL, Model->m_Animated));
            AnimateProp->SetClientData(Model);
            PropMan->SetPropertyAttributeAll(wxPG_BOOL_USE_CHECKBOX, true); // Use checkbox instead of choice.
        }
    }

    PropMan->RefreshGrid();
}


void InspDlgPrimitivePropsT::OnPropertyGridChanged(wxPropertyGridEvent& Event)
{
    MapElementT* Object=(MapElementT*)Event.GetProperty()->GetClientData();

    if (Object==NULL) return;

    if (Object->GetType()==&MapBrushT::TypeInfo)
    {
        // Nothing yet.
    }
    else if (Object->GetType()==&MapBezierPatchT::TypeInfo)
    {
        // Nothing yet.
    }
    else if (Object->GetType()==&MapTerrainT::TypeInfo)
    {
        // Nothing yet.
    }
    else if (Object->GetType()==&MapPlantT::TypeInfo)
    {
        MapPlantT* Plant=(MapPlantT*)Object;

        // Property names are of the kind "MapPlantT[NUMBER].RandomSeed" to identify different map primitives with the
        // same properties. Since we have a pointer identifying the map primitive to modify, we can cut of the first
        // part of the property name.
        if (Event.GetProperty()->GetName().AfterLast('.')=="Random Seed")
        {
            // Command to change the random seed.
            CommandT* Command=new CommandChangePlantSeedT(*MapDoc, Plant, Event.GetProperty()->GetValue().GetLong());

            IsRecursiveSelfNotify=true;
            MapDoc->GetHistory().SubmitCommand(Command);
            IsRecursiveSelfNotify=false;
        }

        if (Event.GetProperty()->GetName().AfterLast('.')=="Plant Description")
        {
            // Command to change the plant description.
            CommandT* Command=new CommandChangePlantDescrT(*MapDoc, Plant, Event.GetProperty()->GetValueAsString());

            IsRecursiveSelfNotify=true;
            MapDoc->GetHistory().SubmitCommand(Command);
            IsRecursiveSelfNotify=false;
        }
    }
    else if (Object->GetType()==&MapModelT::TypeInfo)
    {
        const wxPGProperty* Prop       =Event.GetProperty();
        const wxString      PropName   =Prop->GetName().AfterLast('.');
        double              PropValueD =0.0;
        const float         PropValueF =Prop->GetValue().Convert(&PropValueD) ? float(PropValueD) : 0.0f;

        MapModelT*          Model   =(MapModelT*)Object;
        CommandT*           Command =NULL;

        if (PropName=="Model")
            Command=new CommandModifyModelT(*MapDoc, Model, Prop->GetValueAsString(), Model->m_CollModelFileName, Model->m_Label, Model->m_Scale, Model->m_SeqNumber, Model->m_FrameOffset, Model->m_FrameTimeScale, Model->m_Animated);
        else if (PropName=="Collision Model")
            Command=new CommandModifyModelT(*MapDoc, Model, Model->m_ModelFileName, Prop->GetValueAsString(), Model->m_Label, Model->m_Scale, Model->m_SeqNumber, Model->m_FrameOffset, Model->m_FrameTimeScale, Model->m_Animated);
        else if (PropName=="Label")
            Command=new CommandModifyModelT(*MapDoc, Model, Model->m_ModelFileName, Model->m_CollModelFileName, Prop->GetValueAsString(), Model->m_Scale, Model->m_SeqNumber, Model->m_FrameOffset, Model->m_FrameTimeScale, Model->m_Animated);
        else if (PropName=="Scale")
            Command=new CommandModifyModelT(*MapDoc, Model, Model->m_ModelFileName, Model->m_CollModelFileName, Model->m_Label, PropValueF, Model->m_SeqNumber, Model->m_FrameOffset, Model->m_FrameTimeScale, Model->m_Animated);
        else if (PropName=="Sequence Number")
            Command=new CommandModifyModelT(*MapDoc, Model, Model->m_ModelFileName, Model->m_CollModelFileName, Model->m_Label, Model->m_Scale, Prop->GetValue().GetLong(), Model->m_FrameOffset, Model->m_FrameTimeScale, Model->m_Animated);
        else if (PropName=="Frame Offset")
            Command=new CommandModifyModelT(*MapDoc, Model, Model->m_ModelFileName, Model->m_CollModelFileName, Model->m_Label, Model->m_Scale, Model->m_SeqNumber, PropValueF, Model->m_FrameTimeScale, Model->m_Animated);
        else if (PropName=="Frame Scale")
            Command=new CommandModifyModelT(*MapDoc, Model, Model->m_ModelFileName, Model->m_CollModelFileName, Model->m_Label, Model->m_Scale, Model->m_SeqNumber, Model->m_FrameOffset, PropValueF, Model->m_Animated);
        else if (PropName=="Animated")
            Command=new CommandModifyModelT(*MapDoc, Model, Model->m_ModelFileName, Model->m_CollModelFileName, Model->m_Label, Model->m_Scale, Model->m_SeqNumber, Model->m_FrameOffset, Model->m_FrameTimeScale, Prop->GetValue().GetBool());

        if (Command)
        {
            IsRecursiveSelfNotify=true;
            MapDoc->GetHistory().SubmitCommand(Command);
            IsRecursiveSelfNotify=false;
        }
    }
    else
        // Should never happen.
        wxASSERT(false);
}
