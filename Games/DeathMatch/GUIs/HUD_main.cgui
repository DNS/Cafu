dofile("Games/DeathMatch/GUIs/HUD_init.cgui");

--[[
 This "head-up display" GUI is instantiated by the EntHumanPlayerT entity,
 which in turn binds itself to the global script variable "Player".

 That means that we can call Player methods (as defined in the EntHumanPlayerT
 C++ code) whenever we want to communicate with "our" human player entity,
 e.g.  h = Player:GetHealth()

 Note that the inverse is also possible: The C++ code can directly call our
 scripting functions defined here (there is an example below).
--]]

InfoFrags.NumFrags = 0
FPS.oldTime = FPS:GetTime()
CrossHair.RotateCrosshair = false


function FPS:OnFrame()
    local newTime   = FPS:GetTime()
    local deltaTime = newTime - self.oldTime
    local TextComp  = self:GetComponent("Text")

    if (deltaTime<0.000001) then
        TextComp:set("Text", " FPS  +inf")
    else
        TextComp:set("Text", string.format(" FPS  %.2f", 1/deltaTime))
    end

    FPS.oldTime=newTime;
end


-- This function is directly called from the EntHumanPlayerT code (once per frame).
-- We could integrate it into CrossHair:OnFrame() below, using another method like
-- Player:GetCrosshairInfo(), but keep it for demonstration of direct calls from
-- the entity code to here.
function UpdateCrosshairMaterial(MaterialName, Rotate)
    -- Note that this function is currently called *every* frame by the human player entity code.
    -- However, setting the backMaterial is implemented to be inexpensive when the material name
    -- doesn't change, or else we had to have some code like "if (MaterialName != OldName) ..."
    -- either here or in the entity code.
    CrossHair:GetBasics():set("Show", #MaterialName > 0)
    CrossHair:GetComponent("Image"):set("Material", MaterialName)
    CrossHair.RotateCrosshair=Rotate;
end


-- The OnFrame() methods are called automatically by the Gui System once per frame.
-- While the CrossHair:OnFrame() method splits work with UpdateCrosshairMaterial(),
-- the other OnFrame() methods below are entirely self-contained, using Player methods
-- in order to update themselves.
function CrossHair:OnFrame()
    if (self.RotateCrosshair) then
        self:GetTransform():set("Rotation", self:GetTime() * 50.0)
    else
        self:GetTransform():set("Rotation", 0)
    end
end


function InfoHealth:OnFrame()
    local Health = Player:GetHealth()

    InfoHealth:GetComponent("Text"):set("Text", " Health  " .. Health)

    -- Set the text color of the Health counter linear to its value.
    if (Health>100) then Health=100; end;
    if (Health<  0) then Health=  0; end;

    InfoHealth:GetComponent("Text"):set("Color", 1.0, Health/100, Health/100)
end


function InfoArmor:OnFrame()
    InfoArmor:GetComponent("Text"):set("Text", " Armor  " .. Player:GetArmor())
end


function InfoFrags:OnFrame()
    local Frags = Player:GetFrags()

    InfoFrags:GetComponent("Text"):set("Text", " Frags  " .. Frags)

    -- Trigger a 360 degrees rotation of the Frags counter whenever it changes.
    if (Frags ~= InfoFrags.NumFrags) then
        InfoFrags:GetTransform():interpolate("Rotation", 0, 360, 500)
    end

    InfoFrags.NumFrags = Frags;
end


function InfoAmmo:OnFrame()
    local AmmoString = Player:GetAmmoString()

    if (#AmmoString == 0) then
        InfoAmmo:GetBasics():set("Show", false)
    else
        InfoAmmo:GetBasics():set("Show", true)
        InfoAmmo:GetComponent("Text"):set("Text", AmmoString)
    end
end
