
<h1 class="sectionedit1" id="expressions_and_tables">Expressions and Tables</h1>
<div class="level1">

<p>
Some material keywords take not only plain numbers as their parameters, but entire mathematical expressions that are evaluated whenever the material is employed for rendering. Expressions in turn may refer to look-up tables, which are a very simple but flexible means to approximate arbitrary mathemathical functions.
</p>

<p>
This section explains the details of expressions and tables.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Expressions and Tables&quot;,&quot;hid&quot;:&quot;expressions_and_tables&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:1,&quot;range&quot;:&quot;1-420&quot;} -->
<h2 class="sectionedit2">Expressions</h2>
<div class="level2">

<p>
Some of the above keywords cannot only take numbers as their arguments, but entire mathematical <strong>expressions</strong>.
An expression is a combination of numbers, mathematical operations, symbols, and table look-ups.
Here is an example for such an expression:
</p>
<pre class="code">    (1 + sinTable[ time*0.25 + 3 ]) / 2</pre>

<p>
Unfortunately, there is also bad news: The current parser of the Cafu <abbr title="Cafu Material System">MatSys</abbr> is not yet powerful enough to
parse expressions that use operator infix notation like the one above.
Instead of <code>+</code>, <code>-</code>, <code>*</code>, … we therefore have to use explicit prefix notation,
which is much easier to parse. The prefix notation is explained below.
Here is the above example in prefix notation that we have to use until I can improve the parser to support infix notation:
</p>
<pre class="code">    div(add(1, sinTable[ add(mul(time, 0.25), 3) ]), 2)</pre>

<p>
Expressions are defined recursively as follows:
</p>
<ul>
<li class="level1"><div class="li"> <strong><code>$num</code></strong> A number.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong><code>$var</code></strong> A variable. Please see below for a list of all valid variables.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong><code>$table[ $expr ]</code></strong> A table look-up. The value of the table at position <code>$expr</code> is returned. The details of the look-up depend on the tables definition. The default tables <code>sinTable</code> and <code>cosTable</code> are always predefined. Custom tables can be defined as described in subsection <a href="#expr_and_tables_tables" title="matsys:cmat_manual:expressionsandtables ↵" class="wikilink1">Tables</a>. Note that table look-ups are normalized. That is, all table elements are accessed by indices between 0.0 and 1.0, that is, the fractional part of <code>$expr</code>.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong><code>add($expr1, $expr2)</code></strong> Adds the results of <code>$expr1</code> and <code>$expr2</code>.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong><code>sub($expr1, $expr2)</code></strong> Subtracts the results of <code>$expr1</code> and <code>$expr2</code>.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong><code>mul($expr1, $expr2)</code></strong> Multiplies the results of <code>$expr1</code> and <code>$expr2</code>.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong><code>div($expr1, $expr2)</code></strong> Divides the results of <code>$expr1</code> and <code>$expr2</code> if <code>$expr2</code> is not 0. Otherwise, this evaluates to 0.</div>
</li>
</ul>

<p>
The following variables are defined:
</p>
<ul>
<li class="level1"><div class="li"> <strong><code>time</code></strong> The current system time in seconds, starting from zero.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <strong><code>ambientLightRed</code></strong></div>
</li>
<li class="level1"><div class="li"> <strong><code>ambientLightGreen</code></strong></div>
</li>
<li class="level1"><div class="li"> <strong><code>ambientLightBlue</code></strong> The Cafu engine provides the color of the ambient light <em>that is contributed by radiosity light sources</em> in these variables. Therefore, almost all material definitions that are employed with <em>entities</em> (e.g. player models, weapon and item models, etc.) normally use these variables so that the entity is colored according to the ambient radiosity light. Please see the <code>.<abbr title="Cafu material script file.">cmat</abbr></code> files in <code>Games/DeathMatch/Materials/Models/</code> for many examples.</div>
</li>
</ul>

<p>
Tables and table look-ups are described in subsection <a href="#expr_and_tables_tables" title="matsys:cmat_manual:expressionsandtables ↵" class="wikilink1">Tables</a>.
</p>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Expressions&quot;,&quot;hid&quot;:&quot;expressions&quot;,&quot;codeblockOffset&quot;:0,&quot;secid&quot;:2,&quot;range&quot;:&quot;421-3013&quot;} -->
<h2 class="sectionedit3" id="expr_and_tables_tables">Tables</h2>
<div class="level2">

<p>
A special expression is a table look-up of the form <code>$myTable[$indexExpr]</code>, where <code>$myTable</code> is the name of a table that must have been defined before use, and <code>$indexExpr</code> is another expression that determines where in <code>$myTable</code> the look-up occurs. The scope of <code>$myTable</code> begins at its definition and ends at the end of the material script.
</p>

<p>
Here is a simple but complete example with a table of four values:
</p>
<pre class="code">    // This line defines the table &quot;myTestTable&quot;:
    table myTestTable { { 0.2, 1.4, 0.6, 1 } }

    TestMaterialForTableLookup
    {
        diffusemap  someDiffuseMap.png
        // ...

        rgb div(myTestTable[mul(time, 0.5)], 1.2)   // equiv. to:   rgb myTestTable[time*0.5]/1.2
    }</pre>

<p>
As you can see, table definitions start with the keyword <code>table</code>, followed by the name of the table.
Then come two <code>{</code> brackets, the table data values separated by commas (arbitrarily many), and then the closing two <code>}</code> brackets.
</p>

<p>
Note that table data values are always mapped into the range 0 to 1. Therefore, the graphical representation of <code>myTestTable</code> looks like this:
</p>

<p>
<a href="/_detail/matsys:cmat_manual:table_points.png?id=matsys%3Acmat_manual%3Aexpressionsandtables" class="media" title="matsys:cmat_manual:table_points.png"><img src="/_media/matsys:cmat_manual:table_points.png?w=500&amp;tok=144dc1" class="medialeft" alt="" width="500" /></a> <code>myTestTable[0]</code> yields 0.2, <code>myTestTable[0.25]</code> yields 1.4, and so on… <br style="clear:both" />
</p>

<p>
You may wonder what you get for <code>myTestTable[x]</code> if x is smaller than 0 or greater than 0.75, or what happens if x is “between” two table values. Per default, table values are infinitely repeated outside of the range 0 to 1, and linearly interpolated between two adjacent values. Therefore, <code>myTestTable</code> from the above example in fact represents the following function, graphically shown in light blue color:
</p>

<p>
<a href="/_detail/matsys:cmat_manual:table_default.png?id=matsys%3Acmat_manual%3Aexpressionsandtables" class="media" title="matsys:cmat_manual:table_default.png"><img src="/_media/matsys:cmat_manual:table_default.png?w=500&amp;tok=24c0da" class="medialeft" alt="" width="500" /></a> Observe how the values repeat with each integral number. That is, the table in range 0 to 1 is repeated between 1 to 2, between 2 to 3, 3 to 4, and so on. It is also repeated into the negative range, that is from -1 to 0, from -2 to -1, -3 to -2, and so on.
</p>

<p>
Also observe how intermediate values are linearly interpolated. For example, the value at <code>myTestTable[0.375]</code> (in the mid between 0.25 and 0.5) yields 1.0 as the result. <br style="clear:both" />
</p>

<p>
For example, if you access <code>myTestTable</code> via the <abbr title="Cafu Material System">MatSys</abbr> variable <code>time</code>, as in <code>myTestTable[time]</code>, then it always takes exactly one second to traverse the entire table. If you want to change the speed with which the table is traversed, then you&#039;ll have to multiply the index variable <code>time</code> with an appropriate scale factor. For example, <code>myTestTable[div(time, 3)]</code> will take three seconds to walk the entire table once.
</p>

</div>

<h4>snap and clamp</h4>
<div class="level4">

<p>
For special-purpose tables, you can insert the keywords <code>snap</code> and/or <code>clamp</code> between the two opening <code>{</code> brackets of the table definition.
</p>

<p>
<strong><code>snap</code></strong> turns the linear interpolation off, and instead repeats the previous value until the next table value. Thus, if we changed the definition of our <code>myTestTable</code> above to
</p>
<pre class="code">    table myTestTable { snap { 0.2, 1.4, 0.6, 1 } }</pre>

<p>
then our graphical representation of the table becomes:
</p>

<p>
<a href="/_detail/matsys:cmat_manual:table_snap.png?id=matsys%3Acmat_manual%3Aexpressionsandtables" class="media" title="matsys:cmat_manual:table_snap.png"><img src="/_media/matsys:cmat_manual:table_snap.png?w=500&amp;tok=26c6d8" class="medialeft" alt="" width="500" /></a> <code>snap</code> turns the interpolation off, and just repeats one value until the next. <br style="clear:both" />
</p>

<p>
Snapping is useful whenever you want to have a table to encode functions that have “hard” rather than “smooth” transitions. For example, in order to have LEDs flicker the SOS morse code, you&#039;d use this table:
</p>
<pre class="code">    table sosTable { snap { 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0 } }</pre>

<p>
<strong><code>clamp</code></strong> turns off the repetition of the table values outside of the range 0 to 1. That is, adding <code>clamp</code> to our definition of <code>myTestTable</code> yields:
</p>

<p>
<a href="/_detail/matsys:cmat_manual:table_clamp.png?id=matsys%3Acmat_manual%3Aexpressionsandtables" class="media" title="matsys:cmat_manual:table_clamp.png"><img src="/_media/matsys:cmat_manual:table_clamp.png?w=500&amp;tok=efee37" class="medialeft" alt="" width="500" /></a>
</p>
<pre class="code"> table myTestTable { clamp { 0.2, 1.4, 0.6, 1 } }</pre>

<p>
With <code>clamp</code>, the first table value is returned for <code>myTestTable[x]</code> where x is less than 0, and the last table value is returned whenever x is greater than 1 (in fact, greater than 1-1/TableSize). <br style="clear:both" />
</p>

<p>
Finally, you can also combine <code>snap</code> and <code>clamp</code>:
</p>

<p>
<a href="/_detail/matsys:cmat_manual:table_snap_clamp.png?id=matsys%3Acmat_manual%3Aexpressionsandtables" class="media" title="matsys:cmat_manual:table_snap_clamp.png"><img src="/_media/matsys:cmat_manual:table_snap_clamp.png?w=500&amp;tok=b7fc89" class="medialeft" alt="" width="500" /></a>
</p>
<pre class="code"> table myTestTable { snap clamp { 0.2, 1.4, 0.6, 1 } }</pre>

<p>
<br style="clear:both" />
</p>

</div>

<h4>Predefined Tables</h4>
<div class="level4">

<p>
Normally, tables must be defined before their first use, but there are also tables that are inherently defined by the <abbr title="Cafu Material System">MatSys</abbr> and can always be used without prior definition:
</p>
<ul>
<li class="level1"><div class="li"> <strong><code>sinTable</code></strong> yields the sinus of its argument. Note that the entire 360° (2pi) arc is compressed into the range 0 to 1, not 0 to 2pi.</div>
</li>
<li class="level1"><div class="li"> <strong><code>cosTable</code></strong> yields the cosinus of its argument. Note that the entire 360° (2pi) arc is compressed into the range 0 to 1, not 0 to 2pi.</div>
</li>
<li class="level1"><div class="li"> <strong><code>sinTable01</code></strong> like <code>sinTable</code>, but the values are not returned in range -1 to 1, but “compressed” to 0 to 1. That is, <code>sinTable01[x]</code> is equivalent to <code>div(add(sinTable[x], 1), 2)</code>.</div>
</li>
<li class="level1"><div class="li"> <strong><code>cosTable01</code></strong> like <code>cosTable</code>, but the values are not returned in range -1 to 1, but “compressed” to 0 to 1. That is, <code>cosTable01[x]</code> is equivalent to <code>div(add(cosTable[x], 1), 2)</code>.</div>
</li>
</ul>

</div>
<!-- EDIT{&quot;target&quot;:&quot;section&quot;,&quot;name&quot;:&quot;Tables&quot;,&quot;hid&quot;:&quot;tables&quot;,&quot;codeblockOffset&quot;:2,&quot;secid&quot;:3,&quot;range&quot;:&quot;3014-&quot;} -->